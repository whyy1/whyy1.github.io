<!DOCTYPE html>
































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>MySQL小记 - 歪衣的学习笔记</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="事务的ACID特性： 原子性(使用undo log回滚日志实现)： 事务要么全部执行，要么全部不执行，以原子单位进行处理。
一致性(使用持久性、一致性、原子性)： 事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。
隔离性(使用MVCC多版本控制或锁机制实现)： 一个事务的执行不会被其他事务所干扰。
持续性(使用redo log重做日志实现): 如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。
事务的隔离级别： 读未提交（防止丢失更新，造成脏读）： 一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。
脏读：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。
读已提交（防止脏读，会造成不可重复读）： 事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。
不可重复读：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。
可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读） 一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。
幻读：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）
可串行化（所以问题都可避免，但是造成锁竞争和超时现象） 提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。 索引相关知识 什么是索引？ 索引是为了加速对表中数据行的检索而创建的一种分散的存储结构，用空间换时间。简单来说就是为了让存储引擎更快的查找获取数据。常见的索引有聚簇索引、主键索引、二级索引、唯一索引、hash索引、B&#43;树索引。 Innodb的默认创建的主键索引为聚簇索引，是用B&#43;树实现的，其他的属于二级索引或非聚簇索引。 B&#43;Tree索引 数据都存储在叶子节点，非叶子节点存放键值&#43;指针。 叶子节点中包含所有的索引。 每个小节点都在大节点的范围中。 叶子节点都是使用双指针链接，提高访问性能，比如条件是&gt;或者＜。 如果B&#43;树高度为2的话，根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16 大约 1.8w&#43; 数据 如果B&#43;树高度为3的话，那么这棵B&#43;树的存放总记录数为：根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16kb/14 * 16 大约2kw&#43;数据。 为什么使用B&#43;树作为索引 一个是通过非叶子节点的结构，能够快速二分查找到数据，另一个是叶子节点通过双向链表连接，能够快速的进行区间范围查询。插入操作因为是通过主键自增的话，顺序插入很方便，并且删除时也只需要删除叶子节点就行。
为什么使用B&#43;不使用B TREE B&#43;树在非叶子节点不保存数据，而B树在非叶子节点同样需要保存数据，所以B&#43;树的单个节点数据量更小，可以存储更多的数据。 B&#43;树的叶子节点使用双链表链接，可以更好的进行范围查询。
Hash索引 Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到Hash索引。 存储引擎会为Hash索引中的每一列都计算Hash码，Hash索引中存储的即hash码，所以读取时会进行两次查询。 Hash索引无法用于排序。 Hash索引不使用于区分度小的列上，如性别字段。
B&#43;树索引适合用来做范围查询，而HASH适合做等值查询、搜索复杂度为O（1） 二级索引 也是使用B&#43;树存储，但是和聚簇索引不同的是，二级索引的叶子节点保存的是主键值。在使用二级索引列作为条件进行查询时，会先检索二级索引来获得主键值，然后再去查主键索引的B&#43;树来获得数据，也就是回表。但是如果这时候需要获得的是主键值，就不需要再去查主键索引的B&#43;树，而是直接获得主键值。
如何减少回表操作 将需要查询的字段创建联合索引，尽量使用覆盖索引来查询所需要的数据。 尽量不要使用Select *来查询数据，而是指定具体字段 可以把热门数据进行缓存，避免多次查询。 联合索引存在最左匹配原则 假设A.B.C创建了联合索引，那么针对索引保存顺序来说，只有A是有序的，而B和C是无序的。因此如果在查询条件中没有使用A作为查询条件，就会出现不走联合索引的情况，因为使用索引的情况一定要是有序的。
主键索引 建立在主键字段的索引，这一列必须是唯一的且不能为空" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://whyy1.github.io/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="https://whyy1.github.io/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="https://cdn.whyy1.top/avatar.svg" />
  
  

  
  <link rel="preload" as="image" href="https://whyy1.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://whyy1.github.io/rss.svg" />
  

  
  <link rel="icon" href="https://whyy1.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://whyy1.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.106.0-DEV">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="MySQL小记" />
<meta property="og:description" content="事务的ACID特性： 原子性(使用undo log回滚日志实现)： 事务要么全部执行，要么全部不执行，以原子单位进行处理。
一致性(使用持久性、一致性、原子性)： 事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。
隔离性(使用MVCC多版本控制或锁机制实现)： 一个事务的执行不会被其他事务所干扰。
持续性(使用redo log重做日志实现): 如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。
事务的隔离级别： 读未提交（防止丢失更新，造成脏读）： 一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。
脏读：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。
读已提交（防止脏读，会造成不可重复读）： 事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。
不可重复读：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。
可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读） 一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。
幻读：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）
可串行化（所以问题都可避免，但是造成锁竞争和超时现象） 提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。 索引相关知识 什么是索引？ 索引是为了加速对表中数据行的检索而创建的一种分散的存储结构，用空间换时间。简单来说就是为了让存储引擎更快的查找获取数据。常见的索引有聚簇索引、主键索引、二级索引、唯一索引、hash索引、B&#43;树索引。 Innodb的默认创建的主键索引为聚簇索引，是用B&#43;树实现的，其他的属于二级索引或非聚簇索引。 B&#43;Tree索引 数据都存储在叶子节点，非叶子节点存放键值&#43;指针。 叶子节点中包含所有的索引。 每个小节点都在大节点的范围中。 叶子节点都是使用双指针链接，提高访问性能，比如条件是&gt;或者＜。 如果B&#43;树高度为2的话，根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16 大约 1.8w&#43; 数据 如果B&#43;树高度为3的话，那么这棵B&#43;树的存放总记录数为：根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16kb/14 * 16 大约2kw&#43;数据。 为什么使用B&#43;树作为索引 一个是通过非叶子节点的结构，能够快速二分查找到数据，另一个是叶子节点通过双向链表连接，能够快速的进行区间范围查询。插入操作因为是通过主键自增的话，顺序插入很方便，并且删除时也只需要删除叶子节点就行。
为什么使用B&#43;不使用B TREE B&#43;树在非叶子节点不保存数据，而B树在非叶子节点同样需要保存数据，所以B&#43;树的单个节点数据量更小，可以存储更多的数据。 B&#43;树的叶子节点使用双链表链接，可以更好的进行范围查询。
Hash索引 Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到Hash索引。 存储引擎会为Hash索引中的每一列都计算Hash码，Hash索引中存储的即hash码，所以读取时会进行两次查询。 Hash索引无法用于排序。 Hash索引不使用于区分度小的列上，如性别字段。
B&#43;树索引适合用来做范围查询，而HASH适合做等值查询、搜索复杂度为O（1） 二级索引 也是使用B&#43;树存储，但是和聚簇索引不同的是，二级索引的叶子节点保存的是主键值。在使用二级索引列作为条件进行查询时，会先检索二级索引来获得主键值，然后再去查主键索引的B&#43;树来获得数据，也就是回表。但是如果这时候需要获得的是主键值，就不需要再去查主键索引的B&#43;树，而是直接获得主键值。
如何减少回表操作 将需要查询的字段创建联合索引，尽量使用覆盖索引来查询所需要的数据。 尽量不要使用Select *来查询数据，而是指定具体字段 可以把热门数据进行缓存，避免多次查询。 联合索引存在最左匹配原则 假设A.B.C创建了联合索引，那么针对索引保存顺序来说，只有A是有序的，而B和C是无序的。因此如果在查询条件中没有使用A作为查询条件，就会出现不走联合索引的情况，因为使用索引的情况一定要是有序的。
主键索引 建立在主键字段的索引，这一列必须是唯一的且不能为空" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whyy1.github.io/post/mysql_study/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-11-14T23:50:17+08:00" />
<meta property="article:modified_time" content="2022-11-14T23:50:17+08:00" />


  
  <meta itemprop="name" content="MySQL小记">
<meta itemprop="description" content="事务的ACID特性： 原子性(使用undo log回滚日志实现)： 事务要么全部执行，要么全部不执行，以原子单位进行处理。
一致性(使用持久性、一致性、原子性)： 事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。
隔离性(使用MVCC多版本控制或锁机制实现)： 一个事务的执行不会被其他事务所干扰。
持续性(使用redo log重做日志实现): 如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。
事务的隔离级别： 读未提交（防止丢失更新，造成脏读）： 一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。
脏读：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。
读已提交（防止脏读，会造成不可重复读）： 事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。
不可重复读：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。
可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读） 一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。
幻读：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）
可串行化（所以问题都可避免，但是造成锁竞争和超时现象） 提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。 索引相关知识 什么是索引？ 索引是为了加速对表中数据行的检索而创建的一种分散的存储结构，用空间换时间。简单来说就是为了让存储引擎更快的查找获取数据。常见的索引有聚簇索引、主键索引、二级索引、唯一索引、hash索引、B&#43;树索引。 Innodb的默认创建的主键索引为聚簇索引，是用B&#43;树实现的，其他的属于二级索引或非聚簇索引。 B&#43;Tree索引 数据都存储在叶子节点，非叶子节点存放键值&#43;指针。 叶子节点中包含所有的索引。 每个小节点都在大节点的范围中。 叶子节点都是使用双指针链接，提高访问性能，比如条件是&gt;或者＜。 如果B&#43;树高度为2的话，根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16 大约 1.8w&#43; 数据 如果B&#43;树高度为3的话，那么这棵B&#43;树的存放总记录数为：根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16kb/14 * 16 大约2kw&#43;数据。 为什么使用B&#43;树作为索引 一个是通过非叶子节点的结构，能够快速二分查找到数据，另一个是叶子节点通过双向链表连接，能够快速的进行区间范围查询。插入操作因为是通过主键自增的话，顺序插入很方便，并且删除时也只需要删除叶子节点就行。
为什么使用B&#43;不使用B TREE B&#43;树在非叶子节点不保存数据，而B树在非叶子节点同样需要保存数据，所以B&#43;树的单个节点数据量更小，可以存储更多的数据。 B&#43;树的叶子节点使用双链表链接，可以更好的进行范围查询。
Hash索引 Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到Hash索引。 存储引擎会为Hash索引中的每一列都计算Hash码，Hash索引中存储的即hash码，所以读取时会进行两次查询。 Hash索引无法用于排序。 Hash索引不使用于区分度小的列上，如性别字段。
B&#43;树索引适合用来做范围查询，而HASH适合做等值查询、搜索复杂度为O（1） 二级索引 也是使用B&#43;树存储，但是和聚簇索引不同的是，二级索引的叶子节点保存的是主键值。在使用二级索引列作为条件进行查询时，会先检索二级索引来获得主键值，然后再去查主键索引的B&#43;树来获得数据，也就是回表。但是如果这时候需要获得的是主键值，就不需要再去查主键索引的B&#43;树，而是直接获得主键值。
如何减少回表操作 将需要查询的字段创建联合索引，尽量使用覆盖索引来查询所需要的数据。 尽量不要使用Select *来查询数据，而是指定具体字段 可以把热门数据进行缓存，避免多次查询。 联合索引存在最左匹配原则 假设A.B.C创建了联合索引，那么针对索引保存顺序来说，只有A是有序的，而B和C是无序的。因此如果在查询条件中没有使用A作为查询条件，就会出现不走联合索引的情况，因为使用索引的情况一定要是有序的。
主键索引 建立在主键字段的索引，这一列必须是唯一的且不能为空"><meta itemprop="datePublished" content="2022-11-14T23:50:17+08:00" />
<meta itemprop="dateModified" content="2022-11-14T23:50:17+08:00" />
<meta itemprop="wordCount" content="257">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL小记"/>
<meta name="twitter:description" content="事务的ACID特性： 原子性(使用undo log回滚日志实现)： 事务要么全部执行，要么全部不执行，以原子单位进行处理。
一致性(使用持久性、一致性、原子性)： 事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。
隔离性(使用MVCC多版本控制或锁机制实现)： 一个事务的执行不会被其他事务所干扰。
持续性(使用redo log重做日志实现): 如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。
事务的隔离级别： 读未提交（防止丢失更新，造成脏读）： 一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。
脏读：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。
读已提交（防止脏读，会造成不可重复读）： 事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。
不可重复读：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。
可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读） 一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。
幻读：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）
可串行化（所以问题都可避免，但是造成锁竞争和超时现象） 提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。 索引相关知识 什么是索引？ 索引是为了加速对表中数据行的检索而创建的一种分散的存储结构，用空间换时间。简单来说就是为了让存储引擎更快的查找获取数据。常见的索引有聚簇索引、主键索引、二级索引、唯一索引、hash索引、B&#43;树索引。 Innodb的默认创建的主键索引为聚簇索引，是用B&#43;树实现的，其他的属于二级索引或非聚簇索引。 B&#43;Tree索引 数据都存储在叶子节点，非叶子节点存放键值&#43;指针。 叶子节点中包含所有的索引。 每个小节点都在大节点的范围中。 叶子节点都是使用双指针链接，提高访问性能，比如条件是&gt;或者＜。 如果B&#43;树高度为2的话，根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16 大约 1.8w&#43; 数据 如果B&#43;树高度为3的话，那么这棵B&#43;树的存放总记录数为：根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16kb/14 * 16 大约2kw&#43;数据。 为什么使用B&#43;树作为索引 一个是通过非叶子节点的结构，能够快速二分查找到数据，另一个是叶子节点通过双向链表连接，能够快速的进行区间范围查询。插入操作因为是通过主键自增的话，顺序插入很方便，并且删除时也只需要删除叶子节点就行。
为什么使用B&#43;不使用B TREE B&#43;树在非叶子节点不保存数据，而B树在非叶子节点同样需要保存数据，所以B&#43;树的单个节点数据量更小，可以存储更多的数据。 B&#43;树的叶子节点使用双链表链接，可以更好的进行范围查询。
Hash索引 Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到Hash索引。 存储引擎会为Hash索引中的每一列都计算Hash码，Hash索引中存储的即hash码，所以读取时会进行两次查询。 Hash索引无法用于排序。 Hash索引不使用于区分度小的列上，如性别字段。
B&#43;树索引适合用来做范围查询，而HASH适合做等值查询、搜索复杂度为O（1） 二级索引 也是使用B&#43;树存储，但是和聚簇索引不同的是，二级索引的叶子节点保存的是主键值。在使用二级索引列作为条件进行查询时，会先检索二级索引来获得主键值，然后再去查主键索引的B&#43;树来获得数据，也就是回表。但是如果这时候需要获得的是主键值，就不需要再去查主键索引的B&#43;树，而是直接获得主键值。
如何减少回表操作 将需要查询的字段创建联合索引，尽量使用覆盖索引来查询所需要的数据。 尽量不要使用Select *来查询数据，而是指定具体字段 可以把热门数据进行缓存，避免多次查询。 联合索引存在最左匹配原则 假设A.B.C创建了联合索引，那么针对索引保存顺序来说，只有A是有序的，而B和C是无序的。因此如果在查询条件中没有使用A作为查询条件，就会出现不走联合索引的情况，因为使用索引的情况一定要是有序的。
主键索引 建立在主键字段的索引，这一列必须是唯一的且不能为空"/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href="https://whyy1.github.io/"
      >歪衣的学习笔记</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/whyy1 "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href=" https://whyy1.github.io/index.xml "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">MySQL小记</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Nov 14, 2022</time>
      
      
    </div>
    
  </header>

  <section><h2 id="事务的acid特性">事务的ACID特性：</h2>
<h4 id="原子性使用undo-log回滚日志实现">原子性(使用undo log回滚日志实现)：</h4>
<p>事务要么全部执行，要么全部不执行，以原子单位进行处理。</p>
<h4 id="一致性使用持久性一致性原子性">一致性(使用持久性、一致性、原子性)：</h4>
<p>事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。</p>
<h4 id="隔离性使用mvcc多版本控制或锁机制实现">隔离性(使用MVCC多版本控制或锁机制实现)：</h4>
<p>一个事务的执行不会被其他事务所干扰。</p>
<h4 id="持续性使用redo-log重做日志实现">持续性(使用redo log重做日志实现):</h4>
<p>如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。</p>
<h2 id="事务的隔离级别">事务的隔离级别：</h2>
<h4 id="读未提交防止丢失更新造成脏读">读未提交（防止丢失更新，造成脏读）：</h4>
<p>一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。<br>
<strong>脏读</strong>：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。</p>
<h4 id="读已提交防止脏读会造成不可重复读">读已提交（防止脏读，会造成不可重复读）：</h4>
<p>事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。<br>
<strong>不可重复读</strong>：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。</p>
<h4 id="可重复读mysql的默认事务隔离级别防止不可重复读会造成幻读">可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读）</h4>
<p>一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。<br>
<strong>幻读</strong>：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）</p>
<h4 id="可串行化所以问题都可避免但是造成锁竞争和超时现象">可串行化（所以问题都可避免，但是造成锁竞争和超时现象）</h4>
<p>提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcbba279967f4374b4908c956fb48ff7~tplv-k3u1fbpfcp-zoom-1.image" alt="事务隔离级别与问题"></p>
<h2 id="索引相关知识">索引相关知识</h2>
<h4 id="什么是索引">什么是索引？</h4>
<p>索引是为了加速对表中数据行的检索而创建的一种分散的存储结构，用空间换时间。简单来说就是为了让<strong>存储引擎更快的查找获取数据</strong>。常见的索引有<em>聚簇索引、主键索引、二级索引、唯一索引、hash索引、B+树索引。</em>
Innodb的默认创建的主键索引为聚簇索引，是用B+树实现的，其他的属于二级索引或非聚簇索引。
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7d8a37dfadb4355aab2e7fafe6bf913~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h4 id="btree索引">B+Tree索引</h4>
<ul>
<li>数据都存储在叶子节点，非叶子节点存放键值+指针。</li>
<li>叶子节点中包含所有的索引。</li>
<li>每个小节点都在大节点的范围中。</li>
<li>叶子节点都是使用双指针链接，提高访问性能，比如条件是&gt;或者＜。</li>
<li>如果B+树高度为2的话，根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16 大约 1.8w+ 数据</li>
<li>如果B+树高度为3的话，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数 = 16kb/14 * 16kb/14 * 16 大约2kw+数据。</li>
</ul>
<h3 id="为什么使用b树作为索引">为什么使用B+树作为索引</h3>
<p>一个是通过非叶子节点的结构，能够快速二分查找到数据，另一个是叶子节点通过双向链表连接，能够快速的进行区间范围查询。插入操作因为是通过主键自增的话，顺序插入很方便，并且删除时也只需要删除叶子节点就行。</p>
<h3 id="为什么使用b不使用b-tree">为什么使用B+不使用B TREE</h3>
<p>B+树在非叶子节点不保存数据，而B树在非叶子节点同样需要保存数据，所以B+树的单个节点数据量更小，可以存储更多的数据。
B+树的叶子节点使用双链表链接，可以更好的进行范围查询。</p>
<h4 id="hash索引">Hash索引</h4>
<ul>
<li>Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列才会用到Hash索引。</li>
<li>存储引擎会为Hash索引中的每一列都计算Hash码，Hash索引中存储的即hash码，所以读取时会进行两次查询。</li>
<li>Hash索引无法用于排序。</li>
<li>Hash索引不使用于区分度小的列上，如性别字段。<br>
<strong>B+树索引适合用来做范围查询，而HASH适合做等值查询、搜索复杂度为O（1）</strong></li>
</ul>
<h4 id="二级索引">二级索引</h4>
<p>也是使用B+树存储，但是和聚簇索引不同的是，二级索引的叶子节点保存的是主键值。在使用二级索引列作为条件进行查询时，会先检索二级索引来获得主键值，然后再去查主键索引的B+树来获得数据，也就是回表。但是如果这时候需要获得的是主键值，就不需要再去查主键索引的B+树，而是直接获得主键值。</p>
<h4 id="如何减少回表操作">如何减少回表操作</h4>
<ul>
<li>将需要查询的字段创建联合索引，尽量使用覆盖索引来查询所需要的数据。</li>
<li>尽量不要使用<code>Select *</code>来查询数据，而是指定具体字段</li>
<li>可以把热门数据进行缓存，避免多次查询。</li>
</ul>
<h4 id="联合索引存在最左匹配原则">联合索引存在<em>最左匹配原则</em></h4>
<p>假设A.B.C创建了联合索引，那么针对索引保存顺序来说，只有A是有序的，而B和C是无序的。因此如果在查询条件中没有使用A作为查询条件，就会出现不走联合索引的情况，因为使用索引的情况一定要是有序的。</p>
<h4 id="主键索引">主键索引</h4>
<p>建立在主键字段的索引，这一列必须是唯一的且不能为空</p>
<h4 id="唯一索引">唯一索引</h4>
<p>一列字段唯一的索引，但是可以为空</p>
<h3 id="使用索引可能带来的问题">使用索引可能带来的问题</h3>
<ol>
<li>增加占用物理空间，数量越大，占用空间越大。</li>
<li>创建和维护索引都需要时间，当数据量越大时所花费的时间更多。</li>
<li>有可能让增删改变慢，因为每次进行增删改为了B+树的有序性，都需要维护索引。</li>
</ol>
<h3 id="适合使用索引的场景">适合使用索引的场景</h3>
<ol>
<li>字段唯一的，例如商品编码。</li>
<li>经常需要使用<code>WHERE</code>查询条件的字段，这样能够提高整个表的查询速度，如果查询条件是多个列时，使用联合索引。</li>
<li>经常用于<code>GROUP BY</code>和<code>OREDER BY</code>的字段，这样在查询的时候就不需要再次排序，因为基于B+树的有序性，建立索引之后的记录都是排序的。</li>
</ol>
<h2 id="mysql中的锁">MySQL中的锁</h2>
<h3 id="全局锁">全局锁</h3>
<pre tabindex="0"><code>//加全局锁语句
flush tables with read lock

//释放全局锁
unlock tables
</code></pre><p><strong>全局锁</strong>执行之后数据库处于只读状态，不可修改，其他线程下的<code>insert、delete、update、alter table、drop table</code>等对数据库数据和结构修改的操作都会被阻塞。  <br>
<strong>使用场景</strong>:适用于做全库逻辑备份的时候，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<h3 id="表级锁">表级锁</h3>
<pre tabindex="0"><code>//表级别的共享锁，也就是读锁；
lock tables t_student read;
//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
//会释放当前会话的所有表锁；
unlock tables
</code></pre><p><strong>表级锁</strong>使用表级锁表除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。<br>
<strong>尽量避免</strong>在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</p>
<h4 id="元数据锁mdl为了防止读取数据时表结构改变的情况或者相反情况">元数据锁(MDL)(为了防止读取数据时，表结构改变的情况，或者相反情况)</h4>
<p><strong>元数据锁</strong>不需要显式的进行调用，它会在进行数据库进行CRUD操作时加上MDL读锁，在改变表结构时加上MDL写锁。</p>
<ul>
<li>加MDL读锁是为了在修改或查询数据时，防止表结构变更。</li>
<li>加MDL写锁是为了在改变表结构时阻止CRUD操作，直到表结构变更完成，释放MDL写锁</li>
</ul>
<p>MDL是在<strong>事务提交后才会释放</strong>，这意味着事务执行期间，MDL是一直持有的。申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>。因此在有MDL读锁的情况，可以继续进行CRUD操作，但是一旦有MDL写锁，后续的CRUD操作都会被阻塞。</p>
<h4 id="意向锁为了快速判断表里是否有记录被加锁">意向锁(为了快速判断表里是否有记录被加锁)</h4>
<p><strong>意向锁</strong>是InnoDB引擎在对<strong>表的某些记录</strong>加上共享锁/独占锁之前，需要加上一个<strong>表级别的</strong>意向共享锁/意向独占锁。<br>
在进行<strong>插入、更新、删除</strong>操作，需要先对表加上意向独占锁，然后再对该记录加独占锁。<br>
<strong>普通的 select 是不会加行级锁</strong>的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<pre tabindex="0"><code>//select 也是可以对记录加共享锁和独占锁
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
</code></pre><p><strong>意向锁之间不会冲突，但是会和表级共享锁和独占锁起冲突，满足读读共享、读写互斥、写写互斥</strong></p>
<h4 id="auto-inc锁为了保证表主键顺序递增的锁执行语句立即释放">AUTO-INC锁(为了保证表主键顺序递增的锁，执行语句立即释放)</h4>
<p>在<strong>插入数据</strong>时，会加一个表级别的<strong>AUTO-INC锁</strong>特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。在一个事务持有AUTO-INC锁时，其他事务的插入操作被阻塞，保证的表主键的递增<br>
<strong>MySQL 5.1.22版本</strong>后，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。
一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。
(个人理解是，在插入语句时加锁直接给自增字段赋值为自增值，对该字段赋值完成后直接释放，不需要等到插入语句完全执行之后才释放。)
可以设置模式为innodb_autoinc_lock_mode = 1：，这样在单个语句插入时，自增锁在申请后立即释放。但批量插入时，语句执行完后才会释放。</p>
<h3 id="行级锁innodb支持myisam不支持">行级锁(InnoDB支持，MyISAM不支持)</h3>
<p>普通的select语句是不会对记录加锁的</p>
<pre tabindex="0"><code>//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
</code></pre><p>行级锁有三种</p>
<ul>
<li>Record Lock(记录锁)</li>
<li>Gap Lock(间隙锁，不包含记录本身)</li>
<li>Next-Key Lock(Record Lock + Gap Lock 范围锁，包含记录本身)
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="image.png"></li>
</ul>
<h4 id="record-lock记录锁锁定数据记录">Record Lock(记录锁,锁定数据记录)</h4>
<p>Record Lock 称为记录锁，锁住的是一条记录。当使用<code> select * from t_test where id = 1 for update;</code>，就是给查询的数据加上了独占锁X锁，此时其他的S锁和X锁都被阻塞，其他事务无法对这些数据进行修改。当事务执行commit后，事务过程中生成的锁都会被释放。</p>
<h4 id="gap-lock间隙锁锁定记录的范围不允许对数据范围进行操作不包含记录本身">Gap Lock(间隙锁，锁定记录的范围，不允许对数据范围进行操作，不包含记录本身)</h4>
<p>Gap Lock 称为间隙锁，只存在于<strong>可重复读隔离级别</strong>，目的是为了解决可重复读隔离级别下<strong>幻读</strong>的现象。<br>
锁定数据范围，例如有ID范围3~6的间隙锁，就不允许插入ID为4的语句，防止了幻读。<br>
间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p>
<h4 id="record-lock临键锁锁定数据范围以及范围内的记录不同范围内读锁可以兼容">Record Lock(临键锁,锁定数据范围以及范围内的记录，不同范围内读锁可以兼容)</h4>
<p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
锁定数据范围和数据，例如有ID范围3~6的间隙锁，就不允许插入该范围的数据，也不允许修改该范围的数据。<br>
因为临键锁是记录锁和行锁的组合，所以在相同范围内的临键锁会阻塞，不同范围内的可以兼容。</p>
<h4 id="插入意向锁在插入时判断该位置是否有间隙锁如果有增加一个插入意向锁">插入意向锁(在插入时判断该位置是否有间隙锁，如果有增加一个插入意向锁)</h4>
<p>一个事务在插入一条记录的之前，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<h2 id="mysql的引擎">MySQL的引擎</h2>
<h4 id="innodb引擎">InnoDB引擎</h4>
<p>假设有my_test 的database有个t_order表，则在/var/lib/mysql/my_test目录下有
t_order.<strong>ibd</strong>，t_order 的表数据保存在这个文件<br>
t_order.<strong>frm</strong> ，t_order  的表结构会保存在这个文件</p>
<h5 id="表空间结构">表空间结构</h5>
<p>表空间由段&gt;区&gt;页&gt;行的包含关系存储，InnoDB 的数据是按<strong>页</strong>为单位来读写的，每页的大小为16KB
MySQL的默认引擎，提供了事务操作并使用了<strong>可重复读</strong>作为隔离级别，采用B+树作为默认索引类型，并且提供行锁和外键约束。<br>
MySQL运行的时候，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<h4 id="myisam引擎">MyISAM引擎</h4>
<h4 id="memory引擎">Memory引擎</h4>
<h2 id="分库分表">分库分表</h2>
<ul>
<li>磁盘存储，单机MySQL当数据量较大时，当业务量较大时磁盘使用率大大降低</li>
<li>支撑微服务提高并发操作，在高并发的情况会有大量连接Mysql，分库分表可以让不同的服务访问对应的模块数据库，用于分担读写压力。</li>
</ul>
<h4 id="垂直拆分">垂直拆分</h4>
<ul>
<li>分库：将原本的单库多表，拆分为多库单表，各个业务对应不同的数据库</li>
<li>分表：将表的常用字段和不常用字段进行分开建表，保留基本常用信息字段，还能增快查询。</li>
</ul>
<h4 id="水平拆分">水平拆分</h4>
<ul>
<li>分库：将user数据库分为user1和user2两个库，结构相同只是存储的数据集合不同</li>
<li>分表：按照hans取模或者时间范围对数据进行分表，例如user1（前1000名用户）、user2（1001~2000用户）</li>
</ul>
<h4 id="分库分表导致的问题">分库分表导致的问题</h4>
<ul>
<li>本地事务失效，需要使用分布式事务</li>
<li>需要使用分布式ID，用UUID或者雪花算法生成ID</li>
<li>跨库关联查询时，就需要分别查两次</li>
<li>查询排序，需要查到各个库数据再进行合并</li>
<li>分页查询同上</li>
</ul>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="https://whyy1.github.io/post/go_revise1/"
      ><span class="mr-1.5">←</span><span>并发编程相关知识</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://whyy1.github.io/post/kubernetes/"
      ><span>Kubernetes</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = 'YOUR_DISQUS_SHORTNAME';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60">
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://whyy1.github.io/">歪衣的学习笔记</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank">Powered by Hugo️️</a
  >️
  <a class="link" href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
