<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 歪衣的学习笔记</title>
    <link>https://whyy1.github.io/post/</link>
    <description>Recent content in Posts on 歪衣的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Nov 2022 23:50:17 +0800</lastBuildDate><atom:link href="https://whyy1.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL小记</title>
      <link>https://whyy1.github.io/post/mysql_study/</link>
      <pubDate>Mon, 14 Nov 2022 23:50:17 +0800</pubDate>
      
      <guid>https://whyy1.github.io/post/mysql_study/</guid>
      <description>事务的ACID特性： 原子性： 事务要么全部执行，要么全部不执行，以原子单位进行处理。
一致性： 事务执行的前后，数据的完整性保持一致。类似于银行转账，A向B转账，两个人总额是5000，转账完后总额还会是5000，中途不会不会有数据丢失。
隔离性： 一个事务的执行不会被其他事务所干扰。
持续性 如果一个事务成功提交了，那么它造成的数据改变将是永久的，类似于数据持久化。
事务的隔离级别： 读未提交（防止丢失更新，造成脏读）： 一个事务可以读取到另一个事务已修改但未提交的数据修改，可以有效防止数据更新丢失。如果一个事务开始写数据，则另一个事务不允许同时进行写操作，但是可以读取数据。
脏读：事务A读取到事务B修改的数据，但是事务B却回滚了，读取到不存在的数据或错误数据。
读已提交（防止脏读，会造成不可重复读）： 事务在执行过程中，允许访问其他事务已经提交的插入或修改操作的数据。但是如果一个事务正在进行写事务且未提交，则禁止其他事务访问该行。可以有效防止脏读。
不可重复读：同一个事务中读取一行数据两次，得到两次不一样的结果。在第一次读取后，另一个事务更改了数据并成功提交，就会导致两次读取的数据不同。
可重复读（MySQL的默认事务隔离级别！！防止不可重复读，会造成幻读） 一个事务在执行过程中，可以访问其他事务提交的新插入的数据，但是不能访问其他事务成功修改的数据。读事务时会禁止其他写事务（允许读事务），写事务则禁止其他所有事务。可以有效防止不可重复读和脏读。
幻读：在一个事务中查询数据两次，第一次查询后其他事务提交了新插入的数据，就会造成第二次查询时多出了一条数据，这就是幻读。（和可重复读的区别时，一个是会读到两次不同的数据，一个是会读出多的一些数据）
可串行化（所以问题都可避免，但是造成锁竞争和超时现象） 提供严格的事务隔离，要求事务序列化执行，不能并发操作，即一个事务结束后才会运行下一个事务。可以解决事务并发时出现的问题，脏读、不可重复读、幻读等问题。但是这样会导致大量的超时现象和锁竞争，在实际应用中很少使用。 MySQL的引擎 InnoDB引擎 MySQL的默认引擎，提供了事务操作并使用了可重复读作为隔离级别，采用B+树作为默认索引类型，并且提供行锁和外键约束。
MySQL运行的时候，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。
B+树 1.数据都存储在叶子节点，非叶子节点存放键值+指针。
2.叶子节点中包含所有的索引。
3.每个小姐点都在大节点的范围中。
4.叶子节点都是使用双指针链接，提高访问性能，比如条件是&amp;gt;或者＜。
MyISAM引擎 Memory引擎 </description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://whyy1.github.io/post/kubernetes/</link>
      <pubDate>Thu, 10 Nov 2022 22:46:20 +0800</pubDate>
      
      <guid>https://whyy1.github.io/post/kubernetes/</guid>
      <description>最近把自己一个小玩意儿用docker部署到服务器后，开始尝试了解kubernetes，但是看了一眼阿里云k8s的收费情况，作为学生党当然是选择白嫖。现阶段只是了解学习的阶段，所以选择使用minikube来学习了解k8s。参考文档
Kubernetes 集群 Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。 一个 Kubernetes 集群包含两种类型的资源:
Master 调度整个集群
Master节点负责管理整个集群，控制工作节点。 Nodes 负责运行应用
Node是一个虚拟机或者物理机，作为一个工作节点。它在 Kubernetes 集群中充当工作机器的角色，应该具有Kubelet：管理 Node 而且是 Node 与 Master 通信的代理以及用于处理容器操作的工具。
Master 管理集群，Node 用于托管正在运行的应用。 Deployment （部署） 创建 Kubernetes Deployment 配置，Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。通过修改Deployment文件来控制kubernetes来创建或是修改Pod。个人理解类似于dockerfile，表示应该如何创建Pods。
相关命令
# 查看 deployment kubectl get deployment # 创建命令，可以指定镜像版本 kubectl create deployment hello-node --image=registry.k8s.io/echoserver:1.4 # 也可以通过pod.yaml来部署Pod kubectl apply -f .\pod.yaml # 删除deployment kubectl delete deployment hello-minikube Pods kubernetes调度、管理的最小单位，一个Pod里面可以包含一个或多个容器，每个 Pod 有自己的虚拟IP。是运行一个应用程序的最小单元。
相关命令
# 查看Pods kubectl get pods # 通过命令行运行 kubectl run testapp --image=ccr.</description>
    </item>
    
    <item>
      <title>Hugo博客部署流程</title>
      <link>https://whyy1.github.io/post/hugo_add/</link>
      <pubDate>Tue, 08 Nov 2022 23:33:06 +0800</pubDate>
      
      <guid>https://whyy1.github.io/post/hugo_add/</guid>
      <description>Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。参考了文档以及一个UP主的视频，花了一个晚上的时间弄了一个人博客，最直观的感觉就是非常快速方便。博客地址
下面来做一下总结和流程回顾，首先需要安装Git和Hugo,可以参考视频和文档，都挺详细的。如何验证是否安装成功，运行以下命令出现版本号就说明安装成功了。
hugo version git version 安装好后就可以开始搭建自己的个人博客啦，此文主要记录一些常用操作。Hugo中文网站 、参考视频。
1.创建一个Hugo站点 进入你想要保存文件夹的路径，然后进入CMD，输入以下代码
hugo new site y1_blog #最后为文件夹名字 之后在路径下就会创建一个名为y1_blog的文件夹
2.选取一款皮肤主题 之后进入y1_blog文件夹，选取一款主题安装。皮肤主题网站Hugo上有挺多主题提供选择，我选择的主题是Paper，进入到y1_blog后，运行
git submodule add https://github.com/nanxiaobei/hugo-paper themes/paper 然后在y1_blog\themes下就会多了个paper文件夹，说明已经下载好了，然后在y1_blog目录下修改 config.toml文件的theme为paper
theme = &amp;#34;paper&amp;#34; 同时还可以设置其他一些信息
title = &amp;#39;歪衣的学习笔记&amp;#39; #博客标题名 github = &amp;#39;whyy1&amp;#39; #github用户名 avatar = &amp;#39;https://cdn.whyy1.top/avatar.svg&amp;#39; #设置头像照片链接，格式为svg name = &amp;#39;歪衣&amp;#39; #设置博客用户名字 bio = &amp;#39;学习是稳赚不赔的投资&amp;#39; #设置个性签名 3.启动Hugo服务器 设置好之后，在y1_blog根目录下运行以下命令，就能启动Hugo服务器了。
hugo server -D 如图最后所示，网址输入http://localhost:1313/ 就能访问了。 4.添加一篇文章 刚新建时因为没有文章，所以头像名字啥的有可能显示不出来，因此我们需要新建一篇文章，使用到的命令如下，在y1_blog\content\post\目录下就会新建一个essay.md文件，这是用Markdown格式写的一篇文章。Markdown教程
hugo new post/essay.md 添加好之后再次运行hugo server -D启动Hugo服务器，就可以看到刚才写的文章啦。
5.将博客部署到GitHub上 首先在GitHub上新建一个repository
新建好后复制repository的地址，例如https://whyy1.github.io/ ，然后之后进行一系列上传Git的操作，直接上代码块，有注释，也可以参考视频13:40~20:00的内容。
#在y1_blog/目录下CMD运行 #theme为主题，baseUrl为刚才新建的仓库地址 --buildDrafts为y1_blog/public/目录下生成静态文件 hugo --theme=paper --baseUrl=&amp;#34;https://whyy1.</description>
    </item>
    
    <item>
      <title>docker常用命令</title>
      <link>https://whyy1.github.io/post/essay/</link>
      <pubDate>Tue, 01 Nov 2022 22:48:44 +0800</pubDate>
      
      <guid>https://whyy1.github.io/post/essay/</guid>
      <description>Docker镜像创建 创建dockerflie文件 # 最低版本go的依赖 FROM golang:1.17.7 # 配置模块代理 ENV GOPROXY=https://goproxy.cn,direct # 复制文件目录下的所有代码 ADD . /whygo #默认进入文件目录 WORKDIR /whygo # 复制代码 ADD /whygo/go.mod . ADD /whygo/go.sum . # 下载依赖 RUN go mod download # 运行命令，安装依赖 # 例如 RUN npm install &amp;amp;&amp;amp; cd /app &amp;amp;&amp;amp; mkdir logs # ADD ./whygo . ENV CGO_ENABLED=0 ENV GOOS=linux ENV GOARCH=amd64 # RUN 命令可以有多个，但是可以用 &amp;amp;&amp;amp; 连接多个命令来减少层级。 # 构建exe文件，名字为demo RUN go build -tags netgo -o demo # CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。 # 默认运行 demo ENTRYPOINT [ &amp;#34;.</description>
    </item>
    
  </channel>
</rss>
